% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiREMBO.R
\name{multiREMBO}
\alias{multiREMBO}
\title{Random Embedding Bayesian Optimization}
\usage{
multiREMBO(par, fn, lower, upper, budget, ..., critcontrol = NULL,
  control = list(Atype = "isotropic", reverse = TRUE, Amat = NULL, bxsize =
  NULL, testU = TRUE, standard = FALSE, maxitOptA = 100, lightreturn = FALSE,
  warping = "Psi", covtype = "matern5_2", covreestim = TRUE, designtype =
  "unif", tcheckP = 1e-05, roll = F, initdesigns = NULL, iso = T, inneroptim =
  "pso", popsize = 80, gen = 40))
}
\arguments{
\item{par}{vector whose length is used to define the initial DoE or just the low dimension}

\item{fn}{function to be minimized over}

\item{lower, upper}{bounds for optimization}

\item{budget}{total number of calls to the objective function}

\item{...}{additional parameters of fn}

\item{critcontrol}{optional controls for hypervolume computations, see \code{\link[GPareto]{crit_EHI}}}

\item{control}{an optional list of control parameters. See "Details"}
}
\description{
REMBO for multi-objective unconstrained problems
}
\details{
Options available from control are:
\itemize{
\item \code{Atype} see \code{\link[RRembo]{selectA}};
\item \code{reverse} if \code{TRUE}, use the new mapping from the zonotope,
 otherwise the original mapping with convex projection;
\item \code{Amat} matrix defining the random embedding;
\item \code{bxsize} scalar controling the box size in the low-dimensional space;
\item \code{testU} with the regular mapping, set to \code{TRUE} to check that points are in U (to avoid non-injectivity);
\item \code{standard} for using settings of the original REMBO method;
\item \code{maxitOptA} if \code{Atype} is \code{optimized}, number of optimization iterations;
\item \code{lightreturn} only returns \code{par} and \code{value};
\item \code{warping} either \code{"standard"} for kY, \code{"kX"} or \code{"Psi"};
\item \code{covtype}, \code{covreestim}, \code{iso} see \code{\link[DiceKriging]{km}};
\item \code{designtype} one of "LHS", "maximin" and 'unif',
 see \code{\link[RRembo]{designZ}} or \code{\link[RRembo]{designU}};
\item \code{tcheckP} minimal distance to an existing solution, see \code{\link[GPareto]{checkPredict}}
\item \code{roll} to alternate between optimization methods;
\item \code{initdesigns} initial design matrix
\item \code{inneroptim} optimization method for EI
\item \code{popsize, gen} population size and number of optimization generations of EI
}
}
\examples{
\dontrun{
set.seed(42)
library(GPareto)
library(eaf)

lowd <- 2
highD <- 25

maxEval <- 100

n.grid <- 101
test.grid <- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
response.grid <- t(apply(test.grid, 1, P1))
PFref <- response.grid[is.nondominated(response.grid),]

ii <- c(1,2)
P1_mod <- function(X){
  if(is.null(nrow(X))) X <- matrix(X, nrow = 1)
  return(P1(X[,c(ii[1], ii[2]), drop = FALSE]))
}

plot(response.grid, pch = '.', xlab = "f1", ylab = "f2")                   
plotParetoEmp(PFref, col = "red")

sol <- multiREMBO(par = rep(NA, lowd), P1_mod, lower = rep(0, highD),
                   upper = rep(1, highD), budget = maxEval)
points(sol$values, col = "blue", pch = 20)

}
}
