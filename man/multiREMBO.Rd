% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiREMBO.R
\name{multiREMBO}
\alias{multiREMBO}
\title{Random Embedding Bayesian Optimization}
\usage{
multiREMBO(
  par,
  fn,
  lower,
  upper,
  budget,
  ...,
  critcontrol = list(distance = "euclidean", threshold = 1e-04),
  kmcontrol = list(covtype = "matern5_2", covreestim = TRUE, iso = TRUE, formula = ~1),
  control = list(Atype = "isotropic", reverse = TRUE, bxsize = NULL, testU = TRUE,
    standard = FALSE, maxitOptA = 100, lightreturn = FALSE, warping = "Psi", designtype =
    "unif", roll = F, inneroptim = "pso", popsize = 80, gen = 40),
  init = NULL
)
}
\arguments{
\item{par}{vector whose length is used to define the initial DoE or just the low dimension}

\item{fn}{function to be minimized over}

\item{lower, upper}{bounds for optimization}

\item{budget}{total number of calls to the objective function}

\item{...}{additional parameters of fn}

\item{critcontrol}{optional controls for hypervolume computations, see \code{\link[GPareto]{crit_EHI}}}

\item{kmcontrol}{an optional list of control parameters to be passed to the \code{\link[DiceKriging]{km}} model:
\code{iso}, \code{covtype}, \code{formula}. In addition, boolean \code{codereestim} is passed to \code{\link[DiceKriging]{update.km}}}

\item{control}{an optional list of control parameters. See "Details"}

\item{init}{optional list with elements \code{Amat} to provide a random matrix, \code{low_dim_design} for an initial design in the low-dimensional space and \code{fvalues} for the corresponding response.
When passing initial response values, care should be taken that the mapping with \code{Amat} of the design actually correspond to high-dimensional designs giving \code{fvalues}.}
}
\description{
REMBO for multi-objective unconstrained problems
}
\details{
Options available from control are:
\itemize{
\item \code{Atype} see \code{\link[RRembo]{selectA}};
\item \code{reverse} if \code{TRUE}, use the new mapping from the zonotope,
 otherwise the original mapping with convex projection;
\item \code{Amat} matrix defining the random embedding;
\item \code{bxsize} scalar controling the box size in the low-dimensional space;
\item \code{testU} with the regular mapping, set to \code{TRUE} to check that points are in U (to avoid non-injectivity);
\item \code{standard} for using settings of the original REMBO method;
\item \code{maxitOptA} if \code{Atype} is \code{optimized}, number of optimization iterations;
\item \code{lightreturn} only returns \code{par} and \code{value};
\item \code{warping} either \code{"standard"} for kY, \code{"kX"} or \code{"Psi"};
\item \code{designtype} one of "LHS", "maximin" and 'unif',
 see \code{\link[RRembo]{designZ}} or \code{\link[RRembo]{designU}};
\item \code{tcheckP} minimal distance to an existing solution, see \code{\link[GPareto]{checkPredict}}
\item \code{roll} to alternate between optimization methods;
\item \code{initdesigns} initial design matrix
\item \code{inneroptim} optimization method for EI
\item \code{popsize, gen} population size and number of optimization generations of EI
}
}
\examples{
\dontrun{
set.seed(42)
library(GPareto)
library(eaf)

lowd <- 2
highD <- 25

maxEval <- 100

n.grid <- 101
test.grid <- expand.grid(seq(0, 1, length.out = n.grid), seq(0, 1, length.out = n.grid))
response.grid <- t(apply(test.grid, 1, P1))
PFref <- response.grid[is_nondominated(response.grid),]

ii <- c(1,2)
P1_mod <- function(X){
  if(is.null(nrow(X))) X <- matrix(X, nrow = 1)
  return(P1(X[,c(ii[1], ii[2]), drop = FALSE]))
}

plot(response.grid, pch = '.', xlab = "f1", ylab = "f2")                   
plotParetoEmp(PFref, col = "red")

sol <- multiREMBO(par = rep(NA, lowd), P1_mod, lower = rep(0, highD),
                   upper = rep(1, highD), budget = maxEval)
points(sol$values, col = "blue", pch = 20)

}
}
